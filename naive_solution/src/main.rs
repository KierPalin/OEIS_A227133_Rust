/**
 * Author: Kier Palin
 * The unoptimised naive solution to the problem
 *
 * A grid can be represented as a single integer, where each bit represents a tile.
 * This abstracts the problem into a search for the integer with the greatest popcount,
 * Subject to the square rules.
 *
 * Gosper's Hack is an algorithm to generate all integers of a specified popcount.
 * All possible squares that can be formed in the grid can be pre-calculated,
 * They can then be bitwise ANDed with a grid, if the result is equal to the square then,
 * The grid contains that square & hence is invalid.
 *
 */
extern crate itertools;

use itertools::iproduct; // used by get_squares.
use unfold::Unfold; // used for generating candidate grids via Gosper's hack.

const GRID_LENGTH: u32 = 3;
const GRID_SIZE: u32 = GRID_LENGTH * GRID_LENGTH;

//-----------------------
// Grid Search Functions:
//-----------------------

/**
 * Check all permutations of popcount
 * Recurse to lower popcount if none found.
 */
fn search(squares: Vec<u128>, popcount: u32) -> u128 {
    let permutation_qty: usize = number_of_permutation_with_repititions(popcount) as usize;

    // gospers_hack uses the prior output as input, hence it can be modelled as an unfold operation:
    let candidate_grids: Vec<u128> = Unfold::new(gospers_hack, (1 << popcount) - 1)
        .take(permutation_qty)
        .map(|permutation| permutation as u128)
        .collect();

    // Find the first grid that contains 0 squares:
    let result = candidate_grids
        .into_iter()
        .find(|permutation| !grid_contains_squares(*permutation, &squares));

    // Return or recurse to the lexographically prior permutations - the lesser popcount:
    match result {
        Some(x) => x,
        None => search(squares, popcount - 1),
    }
}

fn grid_contains_squares(grid: u128, squares: &[u128]) -> bool {
    for square in squares {
        if (grid & square) == *square {
            return true;
        }
    }
    false
}

//---------------------------
// Grid Generation Functions:
//---------------------------

/**
 * This is used to take() the precise number of permutations
 * generated by Gospers hack.
 * Neccessary since the permutations are generated via unfolding,
 * which is an infinite structure.
 */
fn number_of_permutation_with_repititions(popcount: u32) -> u32 {
    let popcount_factorial: u32 = ((popcount + 1)..=GRID_SIZE).product();
    let difference_factorial: u32 = (1..=(GRID_SIZE - popcount)).product();
    popcount_factorial / difference_factorial
}

/**
 * This is a bit hack algorithm by Bill Gosper:
 * It generates the candidate grids.
 * Generates the lexographically next permutation given a permutation as input.
 * Initial input is (1 << popcount) - 1
 */
fn gospers_hack(permutation: i128) -> i128 {
    let c: i128 = permutation & -permutation;
    let r = permutation + c;

    (((r ^ permutation) >> 2) / c) | r
}

//-----------------------------
// Square Generation Functions:
//-----------------------------

/**
 * The possible squares in the grid can be pre-calculated
 * These can then be checked against a candidate_grid via bitwise anding
 */
fn get_squares() -> Vec<u128> {
    let squares: Vec<u128> = iproduct!(1..=GRID_SIZE, 2..=GRID_LENGTH)
        .filter(|(index, scale)| valid_square(*index, *scale))
        .map(|(index, scale)| construct_square(index, scale))
        .collect();
    squares
}

/**
 * A square is an integer of entirely zeroes, except for 4 set bits,
 * These 4 set bits are the corners of the square.
 */
fn construct_square(top_left_corner_index: u32, scale: u32) -> u128 {
    let square: u128 = u128::pow(2, top_left_corner_index - 1)
        + u128::pow(2, top_left_corner_index - 1 + scale - 1)
        + u128::pow(2, top_left_corner_index - 1 + (GRID_LENGTH * (scale - 1)))
        + u128::pow(
            2,
            top_left_corner_index - 1 + (GRID_LENGTH * (scale - 1)) + scale - 1,
        );
    square
}

//------------------------------------
// Square Generation Helper Functions:
//------------------------------------

pub fn valid_square(index: u32, scale: u32) -> bool {
    square_within_bounds(index, scale) & !edge_is_on_different_row(index, scale)
}

fn get_current_row(index: u32) -> u32 {
    ((index - 1) + GRID_LENGTH - ((index - 1) % GRID_LENGTH)) / GRID_LENGTH
}

fn edge_is_on_different_row(index: u32, scale: u32) -> bool {
    (get_current_row(index + scale - 1) - get_current_row(index)) > 0
}

fn square_within_bounds(index: u32, scale: u32) -> bool {
    (index + (scale - 1) + GRID_LENGTH * (scale - 1)) <= GRID_SIZE
}

fn main() {
    let squares: Vec<u128> = get_squares();
    let solution = search(squares, GRID_SIZE - GRID_LENGTH + 1);

    println!(
        "Solution: {:0width$b}",
        solution,
        width = GRID_SIZE as usize
    );
}
