#![allow(unused)]

/**
 * Author: Kier Palin
 * The unoptimised naive solution to the problem
 *
 * A grid can be represented as a single integer, where each bit represents a tile.
 * This abstracts the problem into a search for the integer with the greatest popcount,
 * Subject to the square rules.
 *
 * Gosper's Hack is an algorithm to generate all integers of a specified popcount.
 * All possible squares that can be formed in the grid can be pre-calculated,
 * They can then be bitwise ANDed with a grid, if the result is equal to the square then,
 * The grid contains that square & hence is invalid.
 *
 */
extern crate rayon;
use rayon::prelude::*;

extern crate itertools;
use itertools::iproduct; // used by get_squares.

extern crate unfold;
use unfold::Unfold; // used for generating candidate grids via Gosper's hack.

use std::cmp::min;
use std::time::Instant;

const GRID_LENGTH: u32 = 4;
const GRID_SIZE: u32 = GRID_LENGTH * GRID_LENGTH;
const MAX_CHUNK_SIZE: usize = 32000000000; // 4 gigabytes in bits.

//-----------------------
// Grid Search Functions:
//-----------------------

/**
 * While generation the permutations of a popcount is relatively fast - even for large values & popcount distances,
 * There are memory limitations associated with storing that many integers,
 * Furthermore it is not possible to parallelise these generators directly.
 *
 * Hence the generator is used to get a chunk of candidate permutations,
 * These are then
 */

/**
 * Check all permutations of popcount
 * Recurse to lower popcount if none found.
 */
fn search(squares: Vec<u128>, popcount: u32) -> u128 {
    let permutation_qty: usize = number_of_permutation_with_repititions(popcount) as usize;
    let candidate_chunk_size = min(permutation_qty * 128, MAX_CHUNK_SIZE);

    // gospers_hack uses the prior output as input, hence it can be modelled as an unfold operation:
    let gospers_hack_generator = Unfold::new(gospers_hack, (1 << popcount) - 1);

    let candidates = gospers_hack_generator
        .take(permutation_qty)
        .map(|permutation| permutation as u128)
        .collect();

    // Return or recurse to the lexographically prior permutations - the lesser popcount:
    match check_candidates(&squares, candidates) {
        Some(x) => x,
        nil => search(squares, popcount - 1),
    }
}

fn check_candidates(squares: &[u128], candidates: Vec<u128>) -> Option<u128> {
    candidates
        .par_iter()
        .find_any(|&&permutation| !grid_contains_squares(permutation, squares))
        .copied()
}

fn grid_contains_squares(grid: u128, squares: &[u128]) -> bool {
    for square in squares {
        if (grid & square) == *square {
            return true;
        }
    }
    false
}

//---------------------------
// Grid Generation Functions:
//---------------------------

/**
 * This is used to take() the precise number of permutations
 * generated by Gospers hack.
 * Neccessary since the permutations are generated via unfolding,
 * which is an infinite structure.
 */
fn number_of_permutation_with_repititions(popcount: u32) -> u128 {
    let popcount_factorial: u128 = ((popcount + 1)..=GRID_SIZE).map(|x| x as u128).product();
    let difference_factorial: u128 = (1..=(GRID_SIZE - popcount)).map(|x| x as u128).product();
    popcount_factorial / difference_factorial
}

/**
 * This is a bit hack algorithm by Bill Gosper:
 * It generates the candidate grids.
 * Generates the lexographically next permutation given a permutation as input.
 * Initial input is (1 << popcount) - 1
 */
fn gospers_hack(permutation: i128) -> i128 {
    let c: i128 = permutation & -permutation;
    let r = permutation + c;

    (((r ^ permutation) >> 2) / c) | r
}

//-----------------------------
// Square Generation Functions:
//-----------------------------

/**
 * The possible squares in the grid can be pre-calculated
 * These can then be checked against a candidate_grid via bitwise anding
 */
fn get_squares() -> Vec<u128> {
    let squares: Vec<u128> = iproduct!(1..=GRID_SIZE, 2..=GRID_LENGTH)
        .filter(|(index, scale)| valid_square(*index, *scale))
        .map(|(index, scale)| construct_square(index, scale))
        .collect();
    squares
}

/**
 * A square is an integer of entirely zeroes, except for 4 set bits,
 * These 4 set bits are the corners of the square.
 */
fn construct_square(top_left_corner_index: u32, scale: u32) -> u128 {
    let square: u128 = u128::pow(2, top_left_corner_index - 1)
        + u128::pow(2, top_left_corner_index - 1 + scale - 1)
        + u128::pow(2, top_left_corner_index - 1 + (GRID_LENGTH * (scale - 1)))
        + u128::pow(
            2,
            top_left_corner_index - 1 + (GRID_LENGTH * (scale - 1)) + scale - 1,
        );
    square
}

//------------------------------------
// Square Generation Helper Functions:
//------------------------------------

pub fn valid_square(index: u32, scale: u32) -> bool {
    square_within_bounds(index, scale) & !edge_is_on_different_row(index, scale)
}

fn get_current_row(index: u32) -> u32 {
    ((index - 1) + GRID_LENGTH - ((index - 1) % GRID_LENGTH)) / GRID_LENGTH
}

fn edge_is_on_different_row(index: u32, scale: u32) -> bool {
    (get_current_row(index + scale - 1) - get_current_row(index)) > 0
}

fn square_within_bounds(index: u32, scale: u32) -> bool {
    (index + (scale - 1) + GRID_LENGTH * (scale - 1)) <= GRID_SIZE
}

//---------------
// Main Function:
//---------------
fn main() {
    let now = Instant::now();

    let squares: Vec<u128> = get_squares();
    let initial_popcount: u32 = GRID_SIZE - GRID_LENGTH + 1;
    let solution = search(squares, initial_popcount);

    println!(
        "F({}) = {} in {:.2?}.\nSolution: {:0width$b}",
        GRID_LENGTH,
        solution.count_ones(),
        now.elapsed(),
        solution,
        width = GRID_SIZE as usize
    );
}
